
# Multiplying several 4-bit integers by 15

The task of multiplying a certain (large) number of
positive integers by the constant 15 can be optimized
at two levels. Both optimizations can be coded in C, 
but a closer look at the assembly code generated by
[```clang```](https://clang.llvm.org) will subsequently
allow us to optimize the performances of our program
even farther.

## C version

First of all, we can notice that the binary multiplication
between two bit strings can be written as:

	      0 1 0 1 *   (aka 5)
	      0 1 1 0 =   (aka 6)
	      -------
	      0 0 0 0 +
	    0 1 0 1   +
	  0 1 0 1     +
	0 0 0 0       =
	-------------
	0 0 1 1 1 1 0    (aka 30)

Basically, when the involved integers are formed by 4 bits
each, the multiplication can be performed by 3 shifts and 3 
integer sums. However, since one of our two numbers is a known
constant (15), a more efficient procedure (involving fewer
computations) can be proposed. This alternative procedure is 
based on the fact that we can write

$$
15 \times x = 2 \times (4 \times x + x) + (4 \times x + x) ,
$$

and on the fact that multiplications by power of 2 can be 
performed by simple bit shifts. If $x$ is the *one* integer 
number to be multiplied by 15, the following code is equivalent 
to the simple ```15*x```:

	unsigned long computation(unsigned long x)
	{
	   unsigned long four_x = x << 2;  // one shift
	   unsigned long five_x = four_x + x;  // one sum
	   unsigned long ten_x = five_x << 1;  // another shift
	   return ten_x + five_x;  // another sum
	};

We can remark that this code is able to perform the multiplication 
by executing, instead of 4 shifts and 3 integer sums, only 2 shifts
and 2 integer sums. This is [complete C file](./xfifteen-computation.c).

However, there is another way to optimize, when still working
in C. We can noticed that the involved variables are of type 
```unsigned long```, corresponding to integers formed by 64 bits. 
Therefore, we can potentially include 16 integers in only one variable 
of this type. However, when performing the bit shifts, bits related to 
one integer are likely to overlap with others: to prevent this issue, 
we can simply place our initial 4-bit integers in a 8-bit chunk of 
```unsigned long``` variable. See [the main C function](./xfifteen-main.c) 
for more details.

## Assembly version

We have learned, in the previous lesson, how compile C
code (the [C function](./xfifteen-computation.c)) in llvm
and assembly with [```clang```](https://clang.llvm.org).
Please do it and try to read the generated code. In the
following, we are going to focus on the assembly code only, 
and in particular on an entirely handwritten version of the
the C function given above:

	movq    %rdi, %rcx    # rcx = x
	movq    %rdi, %rbx    # rbx = x
	shlq    $2, %rbx      # rbx = 4x
	addq    %rcx, %rbx    # rbx = 5x
	movq    %rbx, %rax    # rax = 5x
	shlq    $1, %rax      # rax = 10x
	addq    %rbx, %rax    # rax = 15x
	retq

Please study the differences with the codes generated by
```clang```, and try to understand why one should prefer this 
handwritten version to the original. Notice that we have no 
communication at all with the central memory in this handwritten
version, and that the used *generic* registers are chosen in opposite 
order w.r.t. the common practice: this allows us to have directly 
the result in the ```rax``` register, where we are supposed to place 
it before ending (avoiding in this way an extra call to ```movq```).

The complete handwritten assembly code is in this 
[asm file](./xfifteen-handwritten.asm). If you feel confident 
with this example, please try to answer an additional question: 
what if the original C function were passing the input argument through
a pointer? Can this fact have any impact on the assembly code (both the 
generated and handwritten ones) ?

## Performance verification

Do you think these improvements on this small code in assembly
may already allow us to observe improvements on the performances of 
our programs? Download this [main C file](./xfifteen-perf.c) and link it,
always using the [```clang```](https://clang.llvm.org) compiler,
with either the compiled [C file](./xfifteen-computation.c),
or the compiled [assembly handwritten file](./fifteen-handwritten.asm).
Then run the executable in both situations. 
Do you see any variations on the performances?

## Credits

This lesson was inspired by the following MIT open course available 
on YouTube: [What compilers can and cannot do](https://www.youtube.com/watch?v=ulJm7_aTiQM).

## Links

* [Back to low-level programming](./README.md)
* [Back to main repository page](../README.md)

